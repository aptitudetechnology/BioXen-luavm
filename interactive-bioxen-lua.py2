#!/usr/bin/env python3
"""
Enhanced Interactive BioXen CLI with hypervisor-like VM management capabilities.
Maintains existing functionality while adding persistent VM control.
"""

import sys
import os
import time
import threading
import signal
import termios
import tty
import select
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent / 'src'))

try:
    import questionary
    from questionary import Choice
except ImportError:
    print("‚ùå questionary not installed. Install with: pip install questionary")
    sys.exit(1)

try:
    # Updated imports for pylua_bioxen_vm_lib version 0.1.19
    from pylua_bioxen_vm_lib import VMManager, SessionManager, create_vm, InteractiveSession
    from pylua_bioxen_vm_lib.exceptions import (
        InteractiveSessionError, AttachError, DetachError, 
        SessionNotFoundError, SessionAlreadyExistsError, 
        VMManagerError, LuaVMError
    )
    # Updated package management imports
    from pylua_bioxen_vm_lib.utils.curator import (
        Curator, get_curator, PackageInstaller, search_packages
    )
    from pylua_bioxen_vm_lib.env import EnvironmentManager
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("Make sure pylua_bioxen_vm_lib>=0.1.19 is installed:")
    print("  pip install --upgrade pylua_bioxen_vm_lib")
    sys.exit(1)

try:
    from rich.console import Console
    from rich.table import Table
    from rich.live import Live
    from rich.panel import Panel
    from rich.text import Text
    from rich.progress import Progress, SpinnerColumn, TextColumn
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    print("‚ö†Ô∏è 'rich' library not available. Install with: pip install rich for enhanced display")


class VMStatus:
    """VM status tracking"""
    def __init__(self, vm_id: str, name: str, created_at: datetime, attached: bool = False):
        self.vm_id = vm_id
        self.name = name
        self.created_at = created_at
        self.attached = attached
        self.last_activity = datetime.now()
    
    def update_activity(self):
        self.last_activity = datetime.now()
    
    def get_uptime(self) -> str:
        uptime = datetime.now() - self.created_at
        hours, remainder = divmod(int(uptime.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        if hours > 0:
            return f"{hours}h {minutes}m {seconds}s"
        elif minutes > 0:
            return f"{minutes}m {seconds}s"
        else:
            return f"{seconds}s"


class TerminalManager:
    """Handles raw terminal mode for VM attachment"""
    
    def __init__(self):
        self.original_attrs = None
        self.raw_mode = False
    
    def enter_raw_mode(self):
        """Enter raw terminal mode for direct VM interaction"""
        if not sys.stdin.isatty():
            return False
        
        try:
            self.original_attrs = termios.tcgetattr(sys.stdin.fileno())
            tty.setraw(sys.stdin.fileno())
            self.raw_mode = True
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Could not enter raw terminal mode: {e}")
            return False
    
    def exit_raw_mode(self):
        """Exit raw terminal mode"""
        if self.raw_mode and self.original_attrs:
            try:
                termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, self.original_attrs)
                self.raw_mode = False
            except Exception as e:
                print(f"‚ö†Ô∏è Could not restore terminal mode: {e}")
    
    def __enter__(self):
        self.enter_raw_mode()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.exit_raw_mode()


class EnhancedInteractiveBioXen:
    """Enhanced Interactive BioXen with hypervisor-like VM management"""
    
    def __init__(self):
        self.vm_manager = VMManager()
        self.vm_status: Dict[str, VMStatus] = {}
        self.console = Console() if RICH_AVAILABLE else None
        self.terminal_manager = TerminalManager()
        self.monitoring_active = False
        self.monitor_thread = None
        
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cleanup_all_vms()
    
    def cleanup_all_vms(self):
        """Clean up all managed VMs on exit"""
        for vm_id in list(self.vm_status.keys()):
            try:
                self.vm_manager.terminate_vm_session(vm_id)
            except:
                pass
        self.vm_status.clear()
    
    # ============ HYPERVISOR COMMANDS ============
    
    def list_persistent_vms(self):
        """List all running persistent VMs with status"""
        print("\n" + "="*60)
        print("üñ•Ô∏è  Persistent Lua VM Status")
        print("="*60)
        
        if not self.vm_status:
            print("üì≠ No persistent VMs running")
            return
        
        if RICH_AVAILABLE and self.console:
            table = Table(show_header=True, header_style="bold blue")
            table.add_column("VM ID", style="cyan")
            table.add_column("Name", style="green")
            table.add_column("Status", style="yellow")
            table.add_column("Uptime", style="magenta")
            table.add_column("Attached", style="red")
            table.add_column("Last Activity", style="dim")
            
            for vm_id, status in self.vm_status.items():
                try:
                    # Check if VM is actually alive
                    sessions = self.vm_manager.session_manager.list_sessions()
                    vm_alive = vm_id in sessions
                    status_text = "üü¢ Running" if vm_alive else "üî¥ Dead"
                    
                    attached_text = "üîó Yes" if status.attached else "‚ûñ No"
                    last_activity = status.last_activity.strftime("%H:%M:%S")
                    
                    table.add_row(
                        vm_id,
                        status.name,
                        status_text,
                        status.get_uptime(),
                        attached_text,
                        last_activity
                    )
                except Exception as e:
                    table.add_row(
                        vm_id,
                        status.name,
                        f"üî¥ Error: {e}",
                        "N/A",
                        "N/A",
                        "N/A"
                    )
            
            self.console.print(table)
        else:
            # Fallback text display
            for vm_id, status in self.vm_status.items():
                try:
                    sessions = self.vm_manager.session_manager.list_sessions()
                    vm_alive = vm_id in sessions
                    status_text = "Running" if vm_alive else "Dead"
                    
                    print(f"VM ID: {vm_id}")
                    print(f"  Name: {status.name}")
                    print(f"  Status: {status_text}")
                    print(f"  Uptime: {status.get_uptime()}")
                    print(f"  Attached: {'Yes' if status.attached else 'No'}")
                    print(f"  Last Activity: {status.last_activity.strftime('%H:%M:%S')}")
                    print()
                except Exception as e:
                    print(f"VM ID: {vm_id} - Error: {e}")
    
    def start_persistent_vm(self):
        """Start a new persistent Lua VM using 0.1.19 multi-VM factory pattern"""
        print("\nüöÄ Start Persistent Lua VM")
        
        vm_id = questionary.text("Enter VM ID (unique identifier):", 
                                validate=lambda x: x and x not in self.vm_status or "VM ID already exists or empty").ask()
        if not vm_id:
            return
        
        vm_name = questionary.text(f"Enter VM name (display name):", default=f"LuaVM-{vm_id}").ask()
        if not vm_name:
            vm_name = f"LuaVM-{vm_id}"
        
        # Choose VM type using new 0.1.19 factory pattern
        vm_type = questionary.select(
            "Select VM type:",
            choices=[
                Choice("üêç Basic VM (subprocess-based)", "basic"),
                Choice("üåê XCP-ng VM (hypervisor, Phase 2)", "xcpng"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()
        
        if not vm_type or vm_type == "back":
            return
        
        networked = questionary.confirm("Enable networking capabilities?", default=False).ask()
        persistent = questionary.confirm("Enable persistent sessions?", default=True).ask()
        debug_mode = questionary.confirm("Enable debug mode?", default=False).ask()
        
        config = None
        if vm_type == "xcpng":
            # Collect XCP-ng configuration
            config = {
                "xcpng_host": questionary.text("XCP-ng host IP:", default="192.168.1.100").ask(),
                "username": questionary.text("Username:", default="root").ask(),
                "password": questionary.password("Password:").ask(),
                "template": questionary.text("Template name:", default="lua-bio-template").ask()
            }
        
        try:
            print(f"üîÑ Creating persistent VM '{vm_id}' (type: {vm_type})...")
            
            # Use new 0.1.19 multi-VM factory pattern
            vm_instance = create_vm(
                vm_id=vm_id, 
                vm_type=vm_type, 
                networked=networked, 
                persistent=persistent, 
                debug_mode=debug_mode,
                config=config
            )
            
            # Create interactive session using VMManager
            session = self.vm_manager.create_interactive_vm(vm_id)
            
            # Register VM status
            self.vm_status[vm_id] = VMStatus(vm_id, vm_name, datetime.now())
            
            if vm_type == "basic":
                # Send initial setup commands for basic VMs
                self.vm_manager.send_input(vm_id, "print('Persistent VM started. Type Lua commands here.')\n")
            time.sleep(0.2)
            
            print(f"‚úÖ Persistent VM '{actual_vm_id}' started successfully!")
            print(f"üí° Use 'Attach to VM Terminal' to interact with it.")
            
        except Exception as e:
            print(f"‚ùå Failed to start persistent VM: {e}")
            import traceback
            traceback.print_exc()
    
    def attach_to_vm_terminal(self):
        """Attach to a persistent VM's terminal"""
        if not self.vm_status:
            print("üì≠ No persistent VMs available")
            return
        
        choices = [Choice(f"{vm_id} ({status.name})", vm_id) for vm_id, status in self.vm_status.items()]
        choices.append(Choice("‚Üê Back to Menu", "back"))
        
        vm_id = questionary.select("Select VM to attach to:", choices=choices).ask()
        
        if not vm_id or vm_id == "back":
            return
        
        try:
            print(f"\nüîó Attaching to VM '{vm_id}'...")
            print("üí° Press Ctrl+D or type 'exit' to detach and return to menu")
            print("üí° The VM will continue running after detachment")
            print("-" * 60)
            
            # Mark as attached
            self.vm_status[vm_id].attached = True
            self.vm_status[vm_id].update_activity()
            
            # Attach to the VM
            self.vm_manager.attach_to_vm(vm_id)
            
            # Start interactive terminal session
            self._run_interactive_terminal(vm_id)
            
        except SessionNotFoundError:
            print(f"‚ùå VM '{vm_id}' not found. It may have been terminated.")
            # Clean up dead VM from status
            if vm_id in self.vm_status:
                del self.vm_status[vm_id]
        except Exception as e:
            print(f"‚ùå Failed to attach to VM: {e}")
        finally:
            # Mark as detached
            if vm_id in self.vm_status:
                self.vm_status[vm_id].attached = False
    
    def _run_interactive_terminal(self, vm_id: str):
        """Run interactive terminal session with VM"""
        try:
            print(f"üñ•Ô∏è  Interactive terminal for VM '{vm_id}' (Ctrl+D to exit)")
            
            while True:
                try:
                    # Get user input
                    user_input = input("lua> ")
                    
                    # Check for exit commands
                    if user_input.lower() in ['exit', 'quit', ':q']:
                        break
                    
                    if user_input.strip():
                        # Send input to VM
                        self.vm_manager.send_input(vm_id, user_input + "\n")
                        self.vm_status[vm_id].update_activity()
                        
                        # Wait a bit for output
                        time.sleep(0.1)
                        
                        # Read and display output
                        output = self.vm_manager.read_output(vm_id)
                        if output:
                            # Clean up the output
                            clean_output = output.strip()
                            if clean_output:
                                print(clean_output)
                
                except EOFError:  # Ctrl+D
                    break
                except KeyboardInterrupt:  # Ctrl+C
                    print("\nüí° Use Ctrl+D or 'exit' to detach from VM")
                    continue
            
            # Detach from VM
            self.vm_manager.detach_from_vm(vm_id)
            print(f"\n‚Ü©Ô∏è  Detached from VM '{vm_id}' (VM continues running)")
            
        except Exception as e:
            print(f"\n‚ùå Terminal session error: {e}")
    
    def detach_from_vm(self):
        """Detach from currently attached VM"""
        attached_vms = [vm_id for vm_id, status in self.vm_status.items() if status.attached]
        
        if not attached_vms:
            print("üì≠ No VMs currently attached")
            return
        
        choices = [Choice(f"{vm_id} ({self.vm_status[vm_id].name})", vm_id) for vm_id in attached_vms]
        
        vm_id = questionary.select("Select VM to detach from:", choices=choices).ask()
        
        if vm_id:
            try:
                self.vm_manager.detach_from_vm(vm_id)
                self.vm_status[vm_id].attached = False
                print(f"‚Ü©Ô∏è  Detached from VM '{vm_id}'")
            except Exception as e:
                print(f"‚ùå Failed to detach from VM: {e}")
    
    def stop_persistent_vm(self):
        """Stop and remove a persistent VM"""
        if not self.vm_status:
            print("üì≠ No persistent VMs to stop")
            return
        
        choices = [Choice(f"{vm_id} ({status.name})", vm_id) for vm_id, status in self.vm_status.items()]
        choices.append(Choice("‚Üê Back to Menu", "back"))
        
        vm_id = questionary.select("Select VM to stop:", choices=choices).ask()
        
        if not vm_id or vm_id == "back":
            return
        
        confirm = questionary.confirm(f"Stop VM '{vm_id}' permanently?", default=False).ask()
        if not confirm:
            return
        
        try:
            self.vm_manager.terminate_vm_session(vm_id)
            del self.vm_status[vm_id]
            print(f"üõë VM '{vm_id}' stopped successfully")
        except Exception as e:
            print(f"‚ùå Failed to stop VM: {e}")
            # Clean up from status anyway
            if vm_id in self.vm_status:
                del self.vm_status[vm_id]
    
    def show_vm_detailed_status(self):
        """Show detailed status for a specific VM"""
        if not self.vm_status:
            print("üì≠ No persistent VMs available")
            return
        
        choices = [Choice(f"{vm_id} ({status.name})", vm_id) for vm_id, status in self.vm_status.items()]
        choices.append(Choice("‚Üê Back to Menu", "back"))
        
        vm_id = questionary.select("Select VM for detailed status:", choices=choices).ask()
        
        if not vm_id or vm_id == "back":
            return
        
        status = self.vm_status[vm_id]
        
        print("\n" + "="*60)
        print(f"üìä Detailed Status for VM '{vm_id}'")
        print("="*60)
        
        try:
            sessions = self.vm_manager.session_manager.list_sessions()
            vm_alive = vm_id in sessions
            
            print(f"VM ID: {vm_id}")
            print(f"Name: {status.name}")
            print(f"Status: {'üü¢ Running' if vm_alive else 'üî¥ Dead'}")
            print(f"Created: {status.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Uptime: {status.get_uptime()}")
            print(f"Currently Attached: {'üîó Yes' if status.attached else '‚ûñ No'}")
            print(f"Last Activity: {status.last_activity.strftime('%Y-%m-%d %H:%M:%S')}")
            
            if vm_alive:
                # Try to get some runtime info
                try:
                    self.vm_manager.send_input(vm_id, "print('Status check:', os.date())\n")
                    time.sleep(0.1)
                    output = self.vm_manager.read_output(vm_id)
                    if output:
                        print(f"Last Response: {output.strip()}")
                except:
                    print("Last Response: Unable to query")
            
        except Exception as e:
            print(f"‚ùå Error getting VM status: {e}")
    
    # ============ ORIGINAL FUNCTIONALITY ============
    
    def create_lua_vm(self):
        """Original VM creation functionality - maintained for compatibility"""
        print("\nüåô Create Lua VM (One-shot Execution)")
        print("üí° This option uses one-time VM execution (original functionality).")
        print("    For persistent VMs, use 'Start Persistent VM' option.")

        vm_manager = VMManager()

        while True:
            lua_action = questionary.select(
                "How would you like to interact with the Lua VM?",
                choices=[
                    Choice("Start Lua Server VM (Socket)", "server_socket"),
                    Choice("Start Lua Client VM (Socket)", "client_socket"),
                    Choice("Start Lua P2P VM (Socket)", "p2p_socket"),
                    Choice("Execute Lua code string", "string"),
                    Choice("Execute Lua script file", "file"),
                    Choice("Back to Main Menu", "back")
                ]
            ).ask()

            if lua_action is None or lua_action == "back":
                print("‚Ü©Ô∏è Returning to main menu.")
                break

            try:
                if lua_action == "server_socket":
                    port = questionary.text("Enter port for Lua Server (e.g., 8080):", default="8080", validate=lambda x: x.isdigit() and 1024 <= int(x) <= 65535 or "Port must be between 1024 and 65535").ask()
                    if not port:
                        continue
                    process_name = f"Lua Server on Port {port}"
                    print(f"\n--- Starting {process_name} ---")
                    print("üí° This process will block until a client connects and sends a message.")
                    output, error = vm_manager.run_server(port=int(port))
                    if output:
                        print(f"--- {process_name} STDOUT ---\n{output.strip()}")
                    if error:
                        print(f"--- {process_name} STDERR ---\n{error.strip()}", file=sys.stderr)

                elif lua_action == "client_socket":
                    ip = questionary.text("Enter Server IP (default: localhost):", default="localhost").ask()
                    if not ip:
                        continue
                    port = questionary.text("Enter Server Port (e.g., 8080):", default="8080", validate=lambda x: x.isdigit() and 1024 <= int(x) <= 65535 or "Port must be between 1024 and 65535").ask()
                    if not port:
                        continue
                    message = questionary.text("Enter message to send to server:", default="Greetings, Lua Server!").ask()
                    if not message:
                        continue
                    process_name = f"Lua Client to {ip}:{port}"
                    print(f"\n--- Starting {process_name} ---")
                    output, error = vm_manager.run_client(ip=ip, port=int(port), message=message)
                    if output:
                        print(f"--- {process_name} STDOUT ---\n{output.strip()}")
                    if error:
                        print(f"--- {process_name} STDERR ---\n{error.strip()}", file=sys.stderr)

                elif lua_action == "p2p_socket":
                    local_port = questionary.text("Enter local port for P2P VM to listen on (e.g., 8081):", default="8081", validate=lambda x: x.isdigit() and 1024 <= int(x) <= 65535 or "Port must be between 1024 and 65535").ask()
                    if not local_port:
                        continue
                    peer_ip_port_str = questionary.text("Enter peer IP:Port to connect to (e.g., localhost:8080, leave blank for no outgoing connection):").ask()
                    peer_ip, peer_port = None, None
                    if peer_ip_port_str:
                        try:
                            peer_ip, peer_port = peer_ip_port_str.split(":")
                            peer_port = int(peer_port)
                        except ValueError:
                            print("‚ùå Invalid peer IP:Port format. Use IP:Port (e.g., localhost:8080).")
                            continue
                    process_name = f"Lua P2P VM (Listen:{local_port}"
                    if peer_ip_port_str:
                        process_name += f", Connect:{peer_ip_port_str})"
                    else:
                        process_name += ")"
                    print(f"\n--- Starting {process_name} ---")
                    print(f"üí° This P2P VM will run for 30 seconds, attempting to listen on port {local_port}")
                    if peer_ip_port_str:
                        print(f"    and connect to peer {peer_ip_port_str}.")
                    output, error = vm_manager.run_p2p(local_port=int(local_port), peer_ip=peer_ip, peer_port=peer_port, run_duration=30)
                    if output:
                        print(f"--- {process_name} STDOUT ---\n{output.strip()}")
                    if error:
                        print(f"--- {process_name} STDERR ---\n{error.strip()}", file=sys.stderr)

                elif lua_action == "string":
                    lua_code = questionary.text("Enter Lua code to execute (e.g., print('Hello')):").ask()
                    if not lua_code:
                        print("‚ö†Ô∏è No Lua code entered. Returning to Lua VM menu.")
                        continue
                    process_name = "Lua Code String"
                    output, error = vm_manager.run_code(lua_code)
                    print(f"--- {process_name} STDOUT ---\n{output.strip() if output else ''}")
                    if error:
                        print(f"--- {process_name} STDERR ---\n{error.strip()}", file=sys.stderr)

                elif lua_action == "file":
                    file_path_str = questionary.text("Enter path to Lua script file (e.g., my_script.lua):").ask()
                    if not file_path_str:
                        print("‚ö†Ô∏è No file path entered. Returning to Lua VM menu.")
                        continue
                    lua_file_path = Path(file_path_str)
                    if not lua_file_path.is_file():
                        print(f"‚ùå Error: File not found at '{lua_file_path}'.")
                        continue
                    process_name = f"Lua Script File: {lua_file_path.name}"
                    output, error = vm_manager.run_script(str(lua_file_path))
                    print(f"--- {process_name} STDOUT ---\n{output.strip() if output else ''}")
                    if error:
                        print(f"--- {process_name} STDERR ---\n{error.strip()}", file=sys.stderr)

            except Exception as e:
                print(f"‚ùå An unexpected error occurred: {e}", file=sys.stderr)
            questionary.press_any_key_to_continue().ask()

    def main_menu(self):
        """Enhanced main menu with hypervisor commands"""
        try:
            while True:
                print("\n" + "="*70)
                print("üåô BioXen Lua VM Manager - Enhanced Hypervisor Interface")
                print("="*70)
                
                # Show quick status
                if self.vm_status:
                    running_count = len(self.vm_status)
                    attached_count = sum(1 for status in self.vm_status.values() if status.attached)
                    print(f"üìä Status: {running_count} VMs running, {attached_count} attached")
                    print("-" * 70)
                
                choices = [
                    # Hypervisor commands
                    Choice("üñ•Ô∏è  List Persistent VMs", "list_vms"),
                    Choice("üöÄ Start Persistent VM", "start_vm"),
                    Choice("üîó Attach to VM Terminal", "attach_vm"),
                    Choice("‚Ü©Ô∏è  Detach from VM", "detach_vm"),
                    Choice("üõë Stop Persistent VM", "stop_vm"),
                    Choice("üìä VM Detailed Status", "vm_status"),
                    Choice("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "separator"),
                    # Package management
                    Choice("üì¶ Package Management", "package_mgmt"),
                    Choice("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "separator2"),
                    # Original functionality
                    Choice("üåô One-shot Lua VM (Original)", "create_lua_vm"),
                    Choice("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "separator2"),
                    Choice("‚ùå Exit", "exit"),
                ]
                
                action = questionary.select(
                    "Select an action:",
                    choices=choices,
                    use_shortcuts=True
                ).ask()
                
                if action is None or action == "exit":
                    print("üõë Stopping all persistent VMs...")
                    self.cleanup_all_vms()
                    print("üëã Goodbye!")
                    break
                
                # Handle separator selections
                if action in ["separator", "separator2"]:
                    continue
                
                try:
                    if action == "list_vms":
                        self.list_persistent_vms()
                    elif action == "start_vm":
                        self.start_persistent_vm()
                    elif action == "attach_vm":
                        self.attach_to_vm_terminal()
                    elif action == "detach_vm":
                        self.detach_from_vm()
                    elif action == "stop_vm":
                        self.stop_persistent_vm()
                    elif action == "vm_status":
                        self.show_vm_detailed_status()
                    elif action == "create_lua_vm":
                        self.create_lua_vm()
                        
                except KeyboardInterrupt:
                    print("\n\n‚ö†Ô∏è Operation cancelled by user")
                    continue
                except Exception as e:
                    print(f"\n‚ùå Error: {e}")
                    import traceback
                    traceback.print_exc()
                
                if action != "attach_vm":  # Don't pause after attach (it handles its own flow)
                    questionary.press_any_key_to_continue().ask()
        
        except KeyboardInterrupt:
            print("\n\nüõë Shutting down...")
            self.cleanup_all_vms()
        except Exception as e:
            print(f"\n‚ùå Fatal error: {e}")
            self.cleanup_all_vms()


def signal_handler(signum, frame):
    """Handle Ctrl+C gracefully"""
    print("\nüõë Received shutdown signal...")
    sys.exit(0)


if __name__ == "__main__":
    # Set up signal handling
    signal.signal(signal.SIGINT, signal_handler)
    
    print("üåô Starting Enhanced BioXen Lua VM Manager...")
    
    try:
        with EnhancedInteractiveBioXen() as cli:
            cli.main_menu()
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        sys.exit(1)