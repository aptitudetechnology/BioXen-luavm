#!/usr/bin/env python3
"""
Fixed VMCLI with proper pylua_bioxen_vm_lib integration and Xen VM support
"""

import os
import sys
import signal
import time
from datetime import datetime
from typing import Dict, List, Optional, Any

try:
    import questionary
    from questionary import Choice
except ImportError:
    print("‚ùå questionary not installed. Install with: pip install questionary")
    sys.exit(1)

try:
    # Correct pylua_bioxen_vm_lib imports
    from pylua_bioxen_vm_lib import VMManager, InteractiveSession, SessionManager
    from pylua_bioxen_vm_lib.exceptions import (
        InteractiveSessionError, AttachError, DetachError, 
        SessionNotFoundError, SessionAlreadyExistsError, 
        VMManagerError, LuaVMError
    )
    # Curator system imports for package management
    from pylua_bioxen_vm_lib.utils.curator import (
        Curator, get_curator, bootstrap_lua_environment, Package
    )
    from pylua_bioxen_vm_lib.env import EnvironmentManager
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("Make sure pylua_bioxen_vm_lib>=0.1.6 is installed:")
    print("  pip install --upgrade pylua_bioxen_vm_lib")
    sys.exit(1)


class VMStatus:
    def __init__(self, profile, vm_type="subprocess"):
        self.profile = profile
        self.vm_type = vm_type  # "subprocess" or "xen"
        self.running = False
        self.attached = False
        self.pid = None
        self.created_at = datetime.now()
        self.packages_installed = 0
        # Xen-specific fields
        self.xen_config = {} if vm_type == "xen" else None

    def get_uptime(self) -> str:
        delta = datetime.now() - self.created_at
        hours = delta.seconds // 3600
        minutes = (delta.seconds % 3600) // 60
        return f"{delta.days}d {hours}h {minutes}m"


class VMCLI:
    def __init__(self):
        self.vm_manager = VMManager()
        self.vm_status = {}
        
        # Initialize curator system
        self.curator = get_curator()
        self.env_manager = EnvironmentManager()

    def main_menu(self):
        print("\n[INFO] BioXen Interactive CLI started. If you do not see the menu below, check your terminal and Python environment.")
        while True:
            action = questionary.select(
                "‚ö° ModularNucleoid CLI - VM Control",
                choices=[
                    Choice("üöÄ Create new Lua VM", "create_vm"),
                    Choice("üîó Attach to existing VM", "attach_vm"),
                    Choice("üì¶ Install Packages", "install_packages"),
                    Choice("üë§ Manage Profiles", "setup_profile"),
                    Choice("üîß Convert VM to Physical", "convert_vm"),
                    Choice("üñ•Ô∏è  Environment Status", "env_status"),
                    Choice("üìã List VMs", "list_vms"),
                    Choice("üõë Stop VM", "stop_vm"),
                    Choice("‚ùå Exit", "exit")
                ]
            ).ask()

            if action == "create_vm":
                self.create_lua_vm()
            elif action == "attach_vm":
                self.attach_to_vm_terminal()
            elif action == "install_packages":
                self.install_packages()
            elif action == "setup_profile":
                self.setup_profile()
            elif action == "convert_vm":
                self.convert_vm_to_physical()
            elif action == "env_status":
                self.show_environment_status()
            elif action == "list_vms":
                self.list_vms()
            elif action == "stop_vm":
                self.stop_vm()
            elif action == "exit":
                self.cleanup()
                sys.exit(0)

    def create_lua_vm(self):
        # Step 1: Choose VM type
        vm_type = questionary.select(
            "Select VM type:",
            choices=[
                Choice("üêç Subprocess VM (Standard Lua process)", "subprocess"),
                Choice("üåê Xen VM (Full hypervisor virtualization)", "xen"),
                Choice("‚Üê Back to Menu", "back")
            ]
        ).ask()
        
        if not vm_type or vm_type == "back":
            return

        vm_id = questionary.text(
            "Enter VM ID (unique identifier):",
            validate=lambda x: x and x not in self.vm_status or "VM ID already exists or empty"
        ).ask()
        if not vm_id:
            return

        profile_name = questionary.text(
            "Enter profile name for this VM:",
            default="standard"
        ).ask()
        if not profile_name:
            profile_name = "standard"

        if vm_type == "subprocess":
            self._create_subprocess_vm(vm_id, profile_name)
        elif vm_type == "xen":
            self._create_xen_vm(vm_id, profile_name)

    def _create_subprocess_vm(self, vm_id, profile_name):
        """Create standard subprocess-based VM"""
        try:
            print(f"üîÑ Creating Subprocess VM '{vm_id}' with profile '{profile_name}'...")
            
            # Create interactive session
            session = self.vm_manager.create_interactive_vm(vm_id)
            
            # Track VM status
            self.vm_status[vm_id] = VMStatus(profile_name, "subprocess")
            self.vm_status[vm_id].running = True

            print(f"‚úÖ Subprocess VM '{vm_id}' created successfully. Use the 'Attach' option to connect to it.")
            
        except Exception as e:
            print(f"‚ùå Failed to create subprocess VM: {e}")
            if vm_id in self.vm_status:
                del self.vm_status[vm_id]

    def _create_xen_vm(self, vm_id, profile_name):
        """Create Xen hypervisor-based VM with configuration"""
        print(f"üåê Configuring Xen VM '{vm_id}'...")
        
        # Collect Xen-specific configuration
        xen_config = self._collect_xen_config()
        if not xen_config:
            return
        
        try:
            print(f"üîÑ Creating Xen VM '{vm_id}' with profile '{profile_name}'...")
            print("‚ö†Ô∏è  Xen VM creation is a placeholder - actual implementation pending")
            
            # Track VM status with Xen config
            self.vm_status[vm_id] = VMStatus(profile_name, "xen")
            self.vm_status[vm_id].xen_config = xen_config
            
            # Placeholder: would create actual Xen VM here
            # self.vm_manager.create_xen_vm(vm_id, xen_config)
            
            print(f"‚úÖ Xen VM '{vm_id}' configuration saved")
            print(f"üîß Memory: {xen_config['memory']}MB, vCPUs: {xen_config['vcpus']}")
            print(f"üíΩ Disk: {xen_config['disk_size']}GB, OS: {xen_config['os_template']}")
            print("‚ö†Ô∏è  Note: Actual Xen VM creation to be implemented in pylua_bioxen_vm_lib")
            
        except Exception as e:
            print(f"‚ùå Failed to create Xen VM: {e}")
            if vm_id in self.vm_status:
                del self.vm_status[vm_id]

    def _collect_xen_config(self):
        """Collect Xen VM configuration from user"""
        print("üîß Configuring Xen VM parameters...")
        
        # Memory configuration
        memory_choices = [
            Choice("512 MB", 512),
            Choice("1 GB", 1024), 
            Choice("2 GB", 2048),
            Choice("4 GB", 4096),
            Choice("Custom amount", "custom")
        ]
        
        memory = questionary.select(
            "Select memory allocation:",
            choices=memory_choices
        ).ask()
        
        if memory == "custom":
            memory = questionary.text(
                "Enter memory in MB:",
                validate=lambda x: x.isdigit() and int(x) > 0 or "Must be positive number"
            ).ask()
            if not memory:
                return None
            memory = int(memory)
        
        # vCPU configuration
        vcpu_choices = [
            Choice("1 vCPU", 1),
            Choice("2 vCPUs", 2),
            Choice("4 vCPUs", 4),
            Choice("Custom count", "custom")
        ]
        
        vcpus = questionary.select(
            "Select vCPU count:",
            choices=vcpu_choices
        ).ask()
        
        if vcpus == "custom":
            vcpus = questionary.text(
                "Enter vCPU count:",
                validate=lambda x: x.isdigit() and int(x) > 0 or "Must be positive number"
            ).ask()
            if not vcpus:
                return None
            vcpus = int(vcpus)
        
        # Disk configuration
        disk_choices = [
            Choice("8 GB", 8),
            Choice("16 GB", 16),
            Choice("32 GB", 32),
            Choice("64 GB", 64),
            Choice("Custom size", "custom")
        ]
        
        disk_size = questionary.select(
            "Select disk size:",
            choices=disk_choices
        ).ask()
        
        if disk_size == "custom":
            disk_size = questionary.text(
                "Enter disk size in GB:",
                validate=lambda x: x.isdigit() and int(x) > 0 or "Must be positive number"
            ).ask()
            if not disk_size:
                return None
            disk_size = int(disk_size)
        
        # OS Template
        os_choices = [
            Choice("Alpine Linux", "alpine"),
            Choice("Custom ISO", "custom")
        ]
        
        os_template = questionary.select(
            "Select OS template:",
            choices=os_choices
        ).ask()
        
        if os_template == "custom":
            iso_path = questionary.text(
                "Enter path to custom ISO:"
            ).ask()
            if not iso_path:
                return None
            os_template = f"custom:{iso_path}"
        
        # Network configuration
        network_type = questionary.select(
            "Select network configuration:",
            choices=[
                Choice("NAT (default)", "nat"),
                Choice("Bridged", "bridge"),
                Choice("Host-only", "hostonly"),
                Choice("No network", "none")
            ]
        ).ask()
        
        # Advanced options
        advanced = questionary.confirm("Configure advanced options?").ask()
        
        xen_config = {
            'memory': memory,
            'vcpus': vcpus,
            'disk_size': disk_size,
            'os_template': os_template,
            'network_type': network_type
        }
        
        if advanced:
            # Boot options
            boot_order = questionary.select(
                "Boot order:",
                choices=[
                    Choice("CD-ROM first (virtual CD-ROM, ISO file installation)", "cd")
                ]
            ).ask()
            xen_config['boot_order'] = boot_order
            
            # Console access
            console = questionary.confirm("Enable serial console access?").ask()
            xen_config['console'] = console
            
            # For headless environments, SSH is recommended for remote access.
            print("[INFO] VNC access is not available (no GUI). Use SSH for remote management.")
        
        # Summary
        print("\nüìã Xen VM Configuration Summary:")
        print(f"  Memory: {memory} MB")
        print(f"  vCPUs: {vcpus}")
        print(f"  Disk: {disk_size} GB")
        print(f"  OS: {os_template}")
        print(f"  Network: {network_type}")
        
        if advanced:
            print(f"  Boot order: {xen_config.get('boot_order', 'default')}")
            print(f"  Console: {'enabled' if xen_config.get('console') else 'disabled'}")
            print(f"  VNC: {'enabled' if xen_config.get('vnc') else 'disabled'}")
        
        confirm = questionary.confirm("Create VM with this configuration?").ask()
        if not confirm:
            return None
            
        return xen_config

    def attach_to_vm_terminal(self):
        if not self.vm_status:
            print("‚ùå No VMs available to attach to")
            return

        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                      if status.running and not status.attached}

        if not running_vms:
            print("‚ùå No running VMs available to attach to")
            return

        vm_choices = [
            Choice(f"{vm_id} ({status.vm_type.title()}, Profile: {status.profile}, Uptime: {status.get_uptime()})", vm_id)
            for vm_id, status in running_vms.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select a VM to attach:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        vm_status = self.vm_status[vm_id]
        
        if vm_status.vm_type == "xen":
            self._attach_to_xen_vm(vm_id)
        else:
            self._attach_to_subprocess_vm(vm_id)

    def _attach_to_subprocess_vm(self, vm_id):
        """Attach to subprocess-based VM"""
        try:
            print(f"üîó Attaching to Subprocess VM '{vm_id}' (Profile: {self.vm_status[vm_id].profile})")
            print("üí° Press Ctrl+D or type 'exit' to detach and return to menu")
            print("üí° The VM will continue running after detachment")
            print("-" * 70)

            self.vm_status[vm_id].attached = True
            
            # Attach to existing session
            session = self.vm_manager.attach_to_vm(vm_id)
            
            self._interactive_loop(vm_id)
            
            self.vm_status[vm_id].attached = False
            print(f"‚úÖ Detached from VM '{vm_id}' - VM continues running")

        except Exception as e:
            print(f"‚ùå Failed to attach to VM: {e}")
            self.vm_status[vm_id].attached = False

    def _attach_to_xen_vm(self, vm_id):
        """Attach to Xen-based VM (placeholder)"""
        print(f"üåê Attaching to Xen VM '{vm_id}'...")
        print("‚ö†Ô∏è  Xen VM attachment is a placeholder - actual implementation pending")
        
        # Show Xen VM info
        xen_config = self.vm_status[vm_id].xen_config
        print(f"üîß VM Configuration:")
        print(f"  Memory: {xen_config.get('memory', 'unknown')} MB")
        print(f"  vCPUs: {xen_config.get('vcpus', 'unknown')}")
        print(f"  Network: {xen_config.get('network_type', 'unknown')}")
        
        # Placeholder console options
        console_choice = questionary.select(
            "Select connection method:",
            choices=[
                Choice("üñ•Ô∏è  Console (xl console)", "console"),
                Choice("üì∫ VNC Viewer", "vnc"),
                Choice("üåê SSH Connection", "ssh"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()
        
        if console_choice == "back":
            return
            
        print(f"‚ö†Ô∏è  {console_choice.upper()} connection placeholder")
        print("Actual Xen VM interaction to be implemented")
        
        questionary.press_any_key_to_continue().ask()

    def _interactive_loop(self, vm_id):
        """Interactive loop for VM session"""
        try:
            while True:
                try:
                    user_input = input(f"lua[{vm_id}]> ")
                    
                    if user_input.strip() in ['exit', 'quit']:
                        break
                    
                    if user_input.strip():
                        self.vm_manager.send_input(vm_id, user_input + "\n")
                        time.sleep(0.1)
                        
                        # Read and display output
                        output = self.vm_manager.read_output(vm_id)
                        if output:
                            print(output.strip())
                            
                except KeyboardInterrupt:
                    print("\nUse 'exit' to detach from VM")
                except EOFError:
                    break
                    
        except Exception as e:
            print(f"Error in interactive loop: {e}")

    def install_packages(self):
        """Enhanced package installation with VM targeting"""
        # First, check available targets
        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                       if status.running}
        # Build target selection
        target_choices = []
        if running_vms:
            target_choices.extend([
                Choice(f"VM: {vm_id} ({status.vm_type.title()}, {status.profile} profile)", f"vm:{vm_id}")
                for vm_id, status in running_vms.items()
            ])
        target_choices.append(Choice("Global system installation", "global"))
        target_choices.append(Choice("‚Üê Back to Menu", "back"))
        # Select installation target
        target = questionary.select(
            "Where would you like to install packages?",
            choices=target_choices
        ).ask()
        if not target or target == "back":
            return
        # Parse target selection
        is_vm_install = target.startswith("vm:")
        target_vm_id = target.split(":", 1)[1] if is_vm_install else None
        
        # Check if target is Xen VM
        if is_vm_install and self.vm_status[target_vm_id].vm_type == "xen":
            print("‚ö†Ô∏è  Package installation to Xen VMs is a placeholder")
            print("Actual Xen VM package management to be implemented")
            questionary.press_any_key_to_continue().ask()
            return
        
        # Select installation type
        install_choice = questionary.select(
            f"How would you like to install packages {'to ' + target_vm_id if is_vm_install else 'globally'}?",
            choices=[
                Choice("Install specific package by name", "specific"),
                Choice("Install recommended packages", "recommended"), 
                Choice("Show available packages", "show_available"),
                Choice("‚Üê Back", "back_to_target")
            ],
            default="specific"
        ).ask()
        if not install_choice or install_choice in ["back_to_target", "back"]:
            if install_choice == "back_to_target":
                self.install_packages()  # Restart from target selection
            return

        try:
            if install_choice == "specific":
                package = questionary.text("Enter package name to install:").ask()
                if package:
                    self._install_single_package(package, is_vm_install, target_vm_id)
            elif install_choice == "recommended":
                recommended = ["luasocket", "luafilesystem", "lua-cjson"]
                confirm = questionary.confirm(
                    f"Install recommended packages: {', '.join(recommended)}?"
                ).ask()
                if confirm:
                    self._install_multiple_packages(recommended, is_vm_install, target_vm_id)
            elif install_choice == "show_available":
                self._show_package_status(is_vm_install, target_vm_id)
        except Exception as e:
            print(f"Package operation failed: {e}")
        questionary.press_any_key_to_continue().ask()

    def _install_single_package(self, package_name, is_vm_install, target_vm_id):
        """Install a single package to VM or global"""
        if is_vm_install:
            print(f"Installing {package_name} to VM '{target_vm_id}'...")
            success = self._install_package_to_vm(package_name, target_vm_id)
            if success:
                print(f"Successfully installed {package_name} to VM '{target_vm_id}'")
                self._verify_package_in_vm(package_name, target_vm_id)
            else:
                print(f"Failed to install {package_name} to VM '{target_vm_id}'")
        else:
            print(f"Installing {package_name} globally...")
            success = self.curator.install_package(package_name)
            if success:
                print(f"Successfully installed {package_name} globally")
            else:
                print(f"Failed to install {package_name} globally")

    def _install_multiple_packages(self, packages, is_vm_install, target_vm_id):
        """Install multiple packages with progress tracking"""
        success_count = 0
        target_desc = f"VM '{target_vm_id}'" if is_vm_install else "globally"
        for pkg in packages:
            print(f"Installing {pkg} {target_desc}...")
            if is_vm_install:
                success = self._install_package_to_vm(pkg, target_vm_id)
            else:
                success = self.curator.install_package(pkg)
            if success:
                print(f"{pkg} installed")
                success_count += 1
                if is_vm_install:
                    self._verify_package_in_vm(pkg, target_vm_id)
            else:
                print(f"{pkg} failed")
        print(f"Installation complete: {success_count}/{len(packages)} successful")

    def _install_package_to_vm(self, package_name, vm_id):
        """Install package directly to a specific VM"""
        try:
            # Send LuaRocks install command to VM
            install_cmd = f'os.execute("luarocks install {package_name}")\n'
            self.vm_manager.send_input(vm_id, install_cmd)
            # Wait for command to complete
            time.sleep(2.0)
            # Read output to check for success
            output = self.vm_manager.read_output(vm_id)
            # Parse output for success indicators
            if output:
                output_lower = output.lower()
                if "successfully installed" in output_lower or "is now installed" in output_lower:
                    return True
                elif "error" in output_lower or "failed" in output_lower:
                    print(f"LuaRocks error: {output.strip()}")
                    return False
            # If no clear indication, assume success (LuaRocks can be quiet on success)
            return True
        except Exception as e:
            print(f"Error installing {package_name} to VM {vm_id}: {e}")
            return False

    def _verify_package_in_vm(self, package_name, vm_id):
        """Verify package can be loaded in VM"""
        try:
            # Try to require the package
            verify_cmd = f'local ok, result = pcall(require, "{package_name}"); print("VERIFY:", ok and "SUCCESS" or "FAILED")\n'
            self.vm_manager.send_input(vm_id, verify_cmd)
            time.sleep(0.5)
            output = self.vm_manager.read_output(vm_id)
            if output and "VERIFY: SUCCESS" in output:
                print(f"Verification: {package_name} loads successfully in VM '{vm_id}'")
            elif output and "VERIFY: FAILED" in output:
                print(f"Warning: {package_name} installed but cannot be loaded in VM '{vm_id}'")
        except Exception as e:
            print(f"Could not verify {package_name} in VM {vm_id}: {e}")

    def _show_package_status(self, is_vm_install, target_vm_id):
        """Show package status for VM or global"""
        try:
            if is_vm_install:
                print(f"\nChecking packages in VM '{target_vm_id}'...")
                # Send command to list installed packages in VM
                list_cmd = 'os.execute("luarocks list")\n'
                self.vm_manager.send_input(target_vm_id, list_cmd)
                time.sleep(1.5)
                output = self.vm_manager.read_output(target_vm_id)
                if output:
                    print("Installed packages in VM:")
                    print(output.strip())
                else:
                    print("No package information available")
            else:
                # Use existing global package listing
                installed = self.curator.list_installed_packages()
                print("\nCurrently Installed Packages (Global):")
                if installed:
                    for pkg in installed:
                        print(f"  ‚Ä¢ {pkg.get('name', 'unknown')} v{pkg.get('version', 'unknown')}")
                else:
                    print("  No packages installed globally")
                # Show health check
                health = self.curator.health_check()
                print(f"\nSystem Health:")
                print(f"  Lua Version: {health.get('lua_version', 'unknown')}")
                print(f"  LuaRocks: {'Available' if health.get('luarocks_available') else 'Unavailable'}")
                print(f"  Total Packages: {health.get('installed_packages', 0)}")
        except Exception as e:
            print(f"Error showing packages: {e}")

    def setup_profile(self):
        profile_choice = questionary.select(
            "Profile management:",
            choices=[
                Choice("Create new profile", "create"),
                Choice("Setup environment profile", "setup_env"),
                Choice("Show current profiles", "show"),
                Choice("‚Üê Back to Menu", "back")
            ]
        ).ask()

        if not profile_choice or profile_choice == "back":
            return

        if profile_choice == "create":
            profile_name = questionary.text("Enter new profile name:").ask()
            if not profile_name:
                print("‚ùå Profile name is required")
                return
            print(f"‚úÖ Profile '{profile_name}' created (functionality to be implemented)")

        elif profile_choice == "setup_env":
            try:
                print("üîÑ Setting up standard environment...")
                success = self.curator.curate_environment("standard")
                if success:
                    print("‚úÖ Standard environment setup complete")
                else:
                    print("‚ùå Environment setup failed")
            except Exception as e:
                print(f"‚ùå Environment setup error: {e}")

        elif profile_choice == "show":
            print("\nüë§ Available Profiles:")
            print("  ‚Ä¢ standard - Standard Lua environment")
            print("  ‚Ä¢ minimal - Minimal Lua setup")
            print("  ‚Ä¢ bioxen - Biological computation focus")
        
        questionary.press_any_key_to_continue().ask()

    def convert_vm_to_physical(self):
        """Convert a virtual Lua VM to physical hardware - UI only, calls library methods"""
        if not self.vm_status:
            print("‚ùå No VMs available for conversion")
            return

        # Select VM to convert
        vm_choices = [
            Choice(f"{vm_id} ({status.vm_type.title()}, Profile: {status.profile}, Status: {'Running' if status.running else 'Stopped'})", vm_id)
            for vm_id, status in self.vm_status.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select VM to convert to physical hardware:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        # Check if Xen VM
        vm_status = self.vm_status[vm_id]
        if vm_status.vm_type == "xen":
            print("‚ö†Ô∏è  Xen VM to physical conversion requires different approach")
            print("Xen VMs already run on physical hardware via hypervisor")
            questionary.press_any_key_to_continue().ask()
            return

        # Select target platform
        platform_choice = questionary.select(
            "Select target platform:",
            choices=[
                Choice("eLua (Embedded Lua)", "elua"),
                Choice("Lumorphix", "lumorphix"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not platform_choice or platform_choice == "back":
            return

        if platform_choice == "elua":
            self._convert_to_elua(vm_id)
        elif platform_choice == "lumorphix":
            self._convert_to_lumorphix(vm_id)

    def _convert_to_elua(self, vm_id):
        """Handle eLua conversion flow"""
        # Select target hardware
        hardware_choice = questionary.select(
            "Select eLua target hardware:",
            choices=[
                Choice("ESP32 (WiFi, Bluetooth)", "esp32"),
                Choice("ESP8266 (WiFi)", "esp8266"), 
                Choice("STM32F4 (ARM Cortex-M4)", "stm32f4"),
                Choice("STM32F1 (ARM Cortex-M3)", "stm32f1"),
                Choice("Custom target", "custom"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not hardware_choice or hardware_choice == "back":
            return

        try:
            print(f"üîß Converting VM '{vm_id}' to eLua for {hardware_choice.upper()}...")
            
            # These would be actual library calls once implemented:
            # converter = self.vm_manager.get_elua_converter()
            # result = converter.convert_vm_to_elua(vm_id, target=hardware_choice)
            
            # For now, just placeholder
            print(f"‚úÖ eLua conversion initiated (placeholder)")
            print(f"üìÅ Would generate: elua_firmware_{vm_id}_{hardware_choice}.bin")
            print(f"üéØ Target: eLua on {hardware_choice.upper()}")
            print(f"‚ö†Ô∏è  Note: Actual conversion logic to be implemented in pylua_bioxen_vm_lib")
            
        except Exception as e:
            print(f"‚ùå eLua conversion failed: {e}")

        questionary.press_any_key_to_continue().ask()

    def _convert_to_lumorphix(self, vm_id):
        """Handle Lumorphix conversion flow"""
        # Select target hardware
        hardware_choice = questionary.select(
            "Select Lumorphix target hardware:",
            choices=[
                Choice("Tang Nano 9k FPGA", "tang_nano_9k"),
                Choice("ELM11", "elm11"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not hardware_choice or hardware_choice == "back":
            return

        try:
            print(f"üîß Converting VM '{vm_id}' to Lumorphix for {hardware_choice.replace('_', ' ').title()}...")
            
            # These would be actual library calls once implemented:
            # converter = self.vm_manager.get_lumorphix_converter()
            # result = converter.convert_vm_to_lumorphix(vm_id, target=hardware_choice)
            
            # For now, just placeholder
            print(f"‚úÖ Lumorphix conversion initiated (placeholder)")
            
            if hardware_choice == "tang_nano_9k":
                print(f"üìÅ Would generate: lumorphix_bitstream_{vm_id}_tang_nano_9k.bit")
                print(f"üéØ Target: Lumorphix on Tang Nano 9k FPGA")
                print(f"üîå FPGA Configuration: Bitstream ready for Tang Nano 9k")
            elif hardware_choice == "elm11":
                print(f"üìÅ Would generate: lumorphix_firmware_{vm_id}_elm11.bin")
                print(f"üéØ Target: Lumorphix on ELM11")
                print(f"üíæ Firmware: Ready for ELM11 flash")
            
            print(f"‚ö†Ô∏è  Note: Actual conversion logic to be implemented in pylua_bioxen_vm_lib")
            
        except Exception as e:
            print(f"‚ùå Lumorphix conversion failed: {e}")

        questionary.press_any_key_to_continue().ask()

    def show_environment_status(self):
        print("\nüñ•Ô∏è  Environment Status:")
        
        # VM status
        if not self.vm_status:
            print("  üì≠ No VMs created yet")
        else:
            print(f"  üñ•Ô∏è  Active VMs: {len(self.vm_status)}")
            for vm_id, status in self.vm_status.items():
                states = []
                if status.running:
                    states.append("Running")
                if status.attached:
                    states.append("Attached")
                if not states:
                    states.append("Stopped")
                
                print(f"    ‚Ä¢ {vm_id}: Profile={status.profile}, "
                      f"Uptime={status.get_uptime()}, State={','.join(states)}")

        # Environment health
        try:
            health = self.curator.health_check()
            print(f"\nüè• System Health:")
            print(f"  üêç Lua Version: {health.get('lua_version', 'unknown')}")
            print(f"  üì¶ LuaRocks: {'Available' if health.get('luarocks_available') else 'Unavailable'}")
            print(f"  üìä Packages: {health.get('installed_packages', 0)}")
            
            errors = self.env_manager.validate_environment()
            if errors:
                print(f"  ‚ö†Ô∏è  Issues: {len(errors)} problems detected")
            else:
                print(f"  ‚úÖ Environment: OK")
                
        except Exception as e:
            print(f"  ‚ùå Health check error: {e}")
        
        questionary.press_any_key_to_continue().ask()


    def list_vms(self):
        if not self.vm_status:
            print("üì≠ No VMs created")
            return

        print("\nüñ•Ô∏è  VM List:")
        print("-" * 80)
        
        for vm_id, status in self.vm_status.items():
            state_indicators = []
            if status.running:
                state_indicators.append("üü¢ Running")
            else:
                state_indicators.append("üî¥ Stopped")
            
            if status.attached:
                state_indicators.append("üîó Attached")
            
            print(f"VM ID: {vm_id}")
            print(f"  Profile: {status.profile}")
            print(f"  Status: {' '.join(state_indicators)}")
            print(f"  Created: {status.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"  Uptime: {status.get_uptime()}")
            print()

        questionary.press_any_key_to_continue().ask()

    def stop_vm(self):
        if not self.vm_status:
            print("üì≠ No VMs to stop")
            return

        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                      if status.running}

        if not running_vms:
            print("üì≠ No running VMs to stop")
            return

        vm_choices = [
            Choice(f"{vm_id} (Profile: {status.profile})", vm_id)
            for vm_id, status in running_vms.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select VM to stop:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        confirm = questionary.confirm(
            f"Stop VM '{vm_id}'? This will terminate the session."
        ).ask()

        if not confirm:
            return

        try:
            self.vm_manager.terminate_vm_session(vm_id)
            del self.vm_status[vm_id]
            print(f"‚úÖ VM '{vm_id}' stopped and removed")
        except Exception as e:
            print(f"‚ùå Failed to stop VM: {e}")
            
        questionary.press_any_key_to_continue().ask()

    def cleanup(self):
        print("\nüßπ Cleaning up running VMs...")
        for vm_id in list(self.vm_status.keys()):
            if self.vm_status[vm_id].running:
                try:
                    self.vm_manager.terminate_vm_session(vm_id)
                    print(f"‚úÖ VM {vm_id} terminated")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Could not terminate VM {vm_id}: {e}")
        self.vm_status.clear()


if __name__ == "__main__":
    try:
        cli = VMCLI()
        cli.main_menu()
    except KeyboardInterrupt:
        print("\nüëã Goodbye!")
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        import traceback
        traceback.print_exc()