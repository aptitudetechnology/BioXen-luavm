#!/usr/bin/env python3
"""
Fixed VMCLI with proper pylua_bioxen_vm_lib integration
"""

import os
import sys
import signal
import time
from datetime import datetime
from typing import Dict, List, Optional, Any

try:
    import questionary
    from questionary import Choice
except ImportError:
    print("‚ùå questionary not installed. Install with: pip install questionary")
    sys.exit(1)

try:
    # Correct pylua_bioxen_vm_lib imports
    from pylua_bioxen_vm_lib import VMManager, InteractiveSession
    from pylua_bioxen_vm_lib.exceptions import (
        InteractiveSessionError, AttachError, DetachError, 
        SessionNotFoundError, SessionAlreadyExistsError, 
        VMManagerError, LuaVMError
    )
    # Curator system imports for package management
    from pylua_bioxen_vm_lib.utils.curator import (
        Curator, get_curator, bootstrap_lua_environment, Package
    )
    from pylua_bioxen_vm_lib.env import EnvironmentManager
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("Make sure pylua_bioxen_vm_lib>=0.1.6 is installed:")
    print("  pip install --upgrade pylua_bioxen_vm_lib")
    sys.exit(1)


class VMStatus:
    def __init__(self, profile):
        self.profile = profile
        self.running = False
        self.attached = False
        self.pid = None
        self.created_at = datetime.now()
        self.packages_installed = 0

    def get_uptime(self) -> str:
        delta = datetime.now() - self.created_at
        hours = delta.seconds // 3600
        minutes = (delta.seconds % 3600) // 60
        return f"{delta.days}d {hours}h {minutes}m"


class VMCLI:
    def __init__(self):
        self.vm_manager = VMManager()
        self.vm_status = {}
        
        # Initialize curator system
        self.curator = get_curator()
        self.env_manager = EnvironmentManager()

    def main_menu(self):
        while True:
            action = questionary.select(
                "‚ö° ModularNucleoid CLI - VM Control",
                choices=[
                    Choice("üöÄ Create new Lua VM", "create_vm"),
                    Choice("üîó Attach to existing VM", "attach_vm"),
                    Choice("üì¶ Install Packages", "install_packages"),
                    Choice("üë§ Manage Profiles", "setup_profile"),
                    Choice("üîß Convert VM to Physical", "convert_vm"),
                    Choice("üñ•Ô∏è  Environment Status", "env_status"),
                    Choice("üìã List VMs", "list_vms"),
                    Choice("üõë Stop VM", "stop_vm"),
                    Choice("‚ùå Exit", "exit")
                ]
            ).ask()

            if action == "create_vm":
                self.create_lua_vm()
            elif action == "attach_vm":
                self.attach_to_vm_terminal()
            elif action == "install_packages":
                self.install_packages()
            elif action == "setup_profile":
                self.setup_profile()
            elif action == "convert_vm":
                self.convert_vm_to_physical()
            elif action == "env_status":
                self.show_environment_status()
            elif action == "list_vms":
                self.list_vms()
            elif action == "stop_vm":
                self.stop_vm()
            elif action == "exit":
                self.cleanup()
                sys.exit(0)

            # after each action (except long-running ones), wait for key
            if action not in ["attach_vm", "env_status", "setup_profile", "convert_vm"]:
                questionary.press_any_key_to_continue().ask()

    def create_lua_vm(self):
        vm_id = questionary.text(
            "Enter VM ID (unique identifier):",
            validate=lambda x: x and x not in self.vm_status or "VM ID already exists or empty"
        ).ask()
        if not vm_id:
            return

        profile_name = questionary.text(
            "Enter profile name for this VM:",
            default="standard"
        ).ask()
        if not profile_name:
            profile_name = "standard"

        try:
            print(f"üîÑ Creating VM '{vm_id}' with profile '{profile_name}'...")
            
            # Create interactive session
            session = self.vm_manager.create_interactive_vm(vm_id)
            
            # Track VM status
            self.vm_status[vm_id] = VMStatus(profile_name)
            self.vm_status[vm_id].running = True

            print(f"‚úÖ VM '{vm_id}' created with profile '{profile_name}'")
            print("üí° Type 'exit' or press Ctrl+D to return to menu")
            print("-" * 70)

            # Mark as attached and enter interactive mode
            self.vm_status[vm_id].attached = True
            
            # Send welcome message
            welcome_msg = f"""
-- VM '{vm_id}' started with {profile_name} profile
print('üåô VM ready! Type Lua commands or exit to return to menu')
"""
            self.vm_manager.send_input(vm_id, welcome_msg)
            time.sleep(0.2)
            
            print("Entering interactive session...")
            self._interactive_loop(vm_id)
            
            self.vm_status[vm_id].attached = False

        except Exception as e:
            print(f"‚ùå Failed to create VM: {e}")
            if vm_id in self.vm_status:
                del self.vm_status[vm_id]

    def attach_to_vm_terminal(self):
        if not self.vm_status:
            print("‚ùå No VMs available to attach to")
            return

        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                      if status.running and not status.attached}

        if not running_vms:
            print("‚ùå No running VMs available to attach to")
            return

        vm_choices = [
            Choice(f"{vm_id} (Profile: {status.profile}, Uptime: {status.get_uptime()})", vm_id)
            for vm_id, status in running_vms.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select a VM to attach:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        try:
            print(f"üîó Attaching to VM '{vm_id}' (Profile: {self.vm_status[vm_id].profile})")
            print("üí° Press Ctrl+D or type 'exit' to detach and return to menu")
            print("üí° The VM will continue running after detachment")
            print("-" * 70)

            self.vm_status[vm_id].attached = True
            
            # Attach to existing session
            session = self.vm_manager.attach_to_vm(vm_id)
            
            self._interactive_loop(vm_id)
            
            self.vm_status[vm_id].attached = False
            print(f"‚úÖ Detached from VM '{vm_id}' - VM continues running")

        except Exception as e:
            print(f"‚ùå Failed to attach to VM: {e}")
            self.vm_status[vm_id].attached = False

    def _interactive_loop(self, vm_id):
        """Interactive loop for VM session"""
        try:
            while True:
                try:
                    user_input = input(f"lua[{vm_id}]> ")
                    
                    if user_input.strip() in ['exit', 'quit']:
                        break
                    
                    if user_input.strip():
                        self.vm_manager.send_input(vm_id, user_input + "\n")
                        time.sleep(0.1)
                        
                        # Read and display output
                        output = self.vm_manager.read_output(vm_id)
                        if output:
                            print(output.strip())
                            
                except KeyboardInterrupt:
                    print("\nUse 'exit' to detach from VM")
                except EOFError:
                    break
                    
        except Exception as e:
            print(f"Error in interactive loop: {e}")

    def install_packages(self):
        """Enhanced package installation with VM targeting"""
        # First, check available targets
        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                       if status.running}
        # Build target selection
        target_choices = []
        if running_vms:
            target_choices.extend([
                Choice(f"VM: {vm_id} ({status.profile} profile)", f"vm:{vm_id}")
                for vm_id, status in running_vms.items()
            ])
        target_choices.append(Choice("Global system installation", "global"))
        target_choices.append(Choice("‚Üê Back to Menu", "back"))
        # Select installation target
        target = questionary.select(
            "Where would you like to install packages?",
            choices=target_choices
        ).ask()
        if not target or target == "back":
            return
        # Parse target selection
        is_vm_install = target.startswith("vm:")
        target_vm_id = target.split(":", 1)[1] if is_vm_install else None
        # Select installation type
        install_choice = questionary.select(
            f"How would you like to install packages {'to ' + target_vm_id if is_vm_install else 'globally'}?",
            choices=[
                Choice("Install specific package by name", "specific"),
                Choice("Install recommended packages", "recommended"), 
                Choice("Show available packages", "show_available"),
                Choice("‚Üê Back", "back_to_target")
            ],
            default="specific"
        ).ask()
        if not install_choice or install_choice in ["back_to_target", "back"]:
            if install_choice == "back_to_target":
                self.install_packages()  # Restart from target selection
            return
        try:
            if install_choice == "specific":
                package = questionary.text("Enter package name to install:").ask()
                if package:
                    self._install_single_package(package, is_vm_install, target_vm_id)
            elif install_choice == "recommended":
                recommended = ["luasocket", "luafilesystem", "lua-cjson"]
                confirm = questionary.confirm(
                    f"Install recommended packages: {', '.join(recommended)}?"
                ).ask()
                if confirm:
                    self._install_multiple_packages(recommended, is_vm_install, target_vm_id)
            elif install_choice == "show_available":
                self._show_package_status(is_vm_install, target_vm_id)
        except Exception as e:
            print(f"Package operation failed: {e}")
        input("Press Enter to return to menu...")

    def _install_single_package(self, package_name, is_vm_install, target_vm_id):
        """Install a single package to VM or global"""
        if is_vm_install:
            print(f"Installing {package_name} to VM '{target_vm_id}'...")
            success = self._install_package_to_vm(package_name, target_vm_id)
            if success:
                print(f"Successfully installed {package_name} to VM '{target_vm_id}'")
                self._verify_package_in_vm(package_name, target_vm_id)
            else:
                print(f"Failed to install {package_name} to VM '{target_vm_id}'")
        else:
            print(f"Installing {package_name} globally...")
            success = self.curator.install_package(package_name)
            if success:
                print(f"Successfully installed {package_name} globally")
            else:
                print(f"Failed to install {package_name} globally")

    def _install_multiple_packages(self, packages, is_vm_install, target_vm_id):
        """Install multiple packages with progress tracking"""
        success_count = 0
        target_desc = f"VM '{target_vm_id}'" if is_vm_install else "globally"
        for pkg in packages:
            print(f"Installing {pkg} {target_desc}...")
            if is_vm_install:
                success = self._install_package_to_vm(pkg, target_vm_id)
            else:
                success = self.curator.install_package(pkg)
            if success:
                print(f"{pkg} installed")
                success_count += 1
                if is_vm_install:
                    self._verify_package_in_vm(pkg, target_vm_id)
            else:
                print(f"{pkg} failed")
        print(f"Installation complete: {success_count}/{len(packages)} successful")

    def _install_package_to_vm(self, package_name, vm_id):
        """Install package directly to a specific VM"""
        try:
            # Send LuaRocks install command to VM
            install_cmd = f'os.execute("luarocks install {package_name}")\n'
            self.vm_manager.send_input(vm_id, install_cmd)
            # Wait for command to complete
            time.sleep(2.0)
            # Read output to check for success
            output = self.vm_manager.read_output(vm_id)
            # Parse output for success indicators
            if output:
                output_lower = output.lower()
                if "successfully installed" in output_lower or "is now installed" in output_lower:
                    return True
                elif "error" in output_lower or "failed" in output_lower:
                    print(f"LuaRocks error: {output.strip()}")
                    return False
            # If no clear indication, assume success (LuaRocks can be quiet on success)
            return True
        except Exception as e:
            print(f"Error installing {package_name} to VM {vm_id}: {e}")
            return False

    def _verify_package_in_vm(self, package_name, vm_id):
        """Verify package can be loaded in VM"""
        try:
            # Try to require the package
            verify_cmd = f'local ok, result = pcall(require, "{package_name}"); print("VERIFY:", ok and "SUCCESS" or "FAILED")\n'
            self.vm_manager.send_input(vm_id, verify_cmd)
            time.sleep(0.5)
            output = self.vm_manager.read_output(vm_id)
            if output and "VERIFY: SUCCESS" in output:
                print(f"Verification: {package_name} loads successfully in VM '{vm_id}'")
            elif output and "VERIFY: FAILED" in output:
                print(f"Warning: {package_name} installed but cannot be loaded in VM '{vm_id}'")
        except Exception as e:
            print(f"Could not verify {package_name} in VM {vm_id}: {e}")

    def _show_package_status(self, is_vm_install, target_vm_id):
        """Show package status for VM or global"""
        try:
            if is_vm_install:
                print(f"\nChecking packages in VM '{target_vm_id}'...")
                # Send command to list installed packages in VM
                list_cmd = 'os.execute("luarocks list")\n'
                self.vm_manager.send_input(target_vm_id, list_cmd)
                time.sleep(1.5)
                output = self.vm_manager.read_output(target_vm_id)
                if output:
                    print("Installed packages in VM:")
                    print(output.strip())
                else:
                    print("No package information available")
            else:
                # Use existing global package listing
                installed = self.curator.list_installed_packages()
                print("\nCurrently Installed Packages (Global):")
                if installed:
                    for pkg in installed:
                        print(f"  ‚Ä¢ {pkg.get('name', 'unknown')} v{pkg.get('version', 'unknown')}")
                else:
                    print("  No packages installed globally")
                # Show health check
                health = self.curator.health_check()
                print(f"\nSystem Health:")
                print(f"  Lua Version: {health.get('lua_version', 'unknown')}")
                print(f"  LuaRocks: {'Available' if health.get('luarocks_available') else 'Unavailable'}")
                print(f"  Total Packages: {health.get('installed_packages', 0)}")
        except Exception as e:
            print(f"Error showing packages: {e}")

    def setup_profile(self):
        profile_choice = questionary.select(
            "Profile management:",
            choices=[
                Choice("Create new profile", "create"),
                Choice("Setup environment profile", "setup_env"),
                Choice("Show current profiles", "show"),
                Choice("‚Üê Back to Menu", "back")
            ]
        ).ask()

        if not profile_choice or profile_choice == "back":
            return

        if profile_choice == "create":
            profile_name = questionary.text("Enter new profile name:").ask()
            if not profile_name:
                print("‚ùå Profile name is required")
                return
            print(f"‚úÖ Profile '{profile_name}' created (functionality to be implemented)")

        elif profile_choice == "setup_env":
            try:
                print("üîÑ Setting up standard environment...")
                success = self.curator.curate_environment("standard")
                if success:
                    print("‚úÖ Standard environment setup complete")
                else:
                    print("‚ùå Environment setup failed")
            except Exception as e:
                print(f"‚ùå Environment setup error: {e}")

        elif profile_choice == "show":
            print("\nüë§ Available Profiles:")
            print("  ‚Ä¢ standard - Standard Lua environment")
            print("  ‚Ä¢ minimal - Minimal Lua setup")
            print("  ‚Ä¢ bioxen - Biological computation focus")

    def convert_vm_to_physical(self):
        """Convert a virtual Lua VM to physical hardware - UI only, calls library methods"""
        if not self.vm_status:
            print("‚ùå No VMs available for conversion")
            return

        # Select VM to convert
        vm_choices = [
            Choice(f"{vm_id} (Profile: {status.profile}, Status: {'Running' if status.running else 'Stopped'})", vm_id)
            for vm_id, status in self.vm_status.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select VM to convert to physical hardware:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        # Select target platform
        platform_choice = questionary.select(
            "Select target platform:",
            choices=[
                Choice("eLua (Embedded Lua)", "elua"),
                Choice("Lumorphix", "lumorphix"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not platform_choice or platform_choice == "back":
            return

        if platform_choice == "elua":
            self._convert_to_elua(vm_id)
        elif platform_choice == "lumorphix":
            self._convert_to_lumorphix(vm_id)

    def _convert_to_elua(self, vm_id):
        """Handle eLua conversion flow"""
        # Select target hardware
        hardware_choice = questionary.select(
            "Select eLua target hardware:",
            choices=[
                Choice("ESP32 (WiFi, Bluetooth)", "esp32"),
                Choice("ESP8266 (WiFi)", "esp8266"), 
                Choice("STM32F4 (ARM Cortex-M4)", "stm32f4"),
                Choice("STM32F1 (ARM Cortex-M3)", "stm32f1"),
                Choice("Custom target", "custom"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not hardware_choice or hardware_choice == "back":
            return

        try:
            print(f"üîß Converting VM '{vm_id}' to eLua for {hardware_choice.upper()}...")
            
            # These would be actual library calls once implemented:
            # converter = self.vm_manager.get_elua_converter()
            # result = converter.convert_vm_to_elua(vm_id, target=hardware_choice)
            
            # For now, just placeholder
            print(f"‚úÖ eLua conversion initiated (placeholder)")
            print(f"üìÅ Would generate: elua_firmware_{vm_id}_{hardware_choice}.bin")
            print(f"üéØ Target: eLua on {hardware_choice.upper()}")
            print(f"‚ö†Ô∏è  Note: Actual conversion logic to be implemented in pylua_bioxen_vm_lib")
            
        except Exception as e:
            print(f"‚ùå eLua conversion failed: {e}")

        input("Press Enter to continue...")

    def _convert_to_lumorphix(self, vm_id):
        """Handle Lumorphix conversion flow"""
        # Select target hardware
        hardware_choice = questionary.select(
            "Select Lumorphix target hardware:",
            choices=[
                Choice("Tang Nano 9k FPGA", "tang_nano_9k"),
                Choice("ELM11", "elm11"),
                Choice("‚Üê Back", "back")
            ]
        ).ask()

        if not hardware_choice or hardware_choice == "back":
            return

        try:
            print(f"üîß Converting VM '{vm_id}' to Lumorphix for {hardware_choice.replace('_', ' ').title()}...")
            
            # These would be actual library calls once implemented:
            # converter = self.vm_manager.get_lumorphix_converter()
            # result = converter.convert_vm_to_lumorphix(vm_id, target=hardware_choice)
            
            # For now, just placeholder
            print(f"‚úÖ Lumorphix conversion initiated (placeholder)")
            
            if hardware_choice == "tang_nano_9k":
                print(f"üìÅ Would generate: lumorphix_bitstream_{vm_id}_tang_nano_9k.bit")
                print(f"üéØ Target: Lumorphix on Tang Nano 9k FPGA")
                print(f"üîå FPGA Configuration: Bitstream ready for Tang Nano 9k")
            elif hardware_choice == "elm11":
                print(f"üìÅ Would generate: lumorphix_firmware_{vm_id}_elm11.bin")
                print(f"üéØ Target: Lumorphix on ELM11")
                print(f"üíæ Firmware: Ready for ELM11 flash")
            
            print(f"‚ö†Ô∏è  Note: Actual conversion logic to be implemented in pylua_bioxen_vm_lib")
            
        except Exception as e:
            print(f"‚ùå Lumorphix conversion failed: {e}")

        input("Press Enter to continue...")

    def show_environment_status(self):
        print("\nüñ•Ô∏è  Environment Status:")
        
        # VM status
        if not self.vm_status:
            print("  üì≠ No VMs created yet")
        else:
            print(f"  üñ•Ô∏è  Active VMs: {len(self.vm_status)}")
            for vm_id, status in self.vm_status.items():
                states = []
                if status.running:
                    states.append("Running")
                if status.attached:
                    states.append("Attached")
                if not states:
                    states.append("Stopped")
                
                print(f"    ‚Ä¢ {vm_id}: Profile={status.profile}, "
                      f"Uptime={status.get_uptime()}, State={','.join(states)}")

        # Environment health
        try:
            health = self.curator.health_check()
            print(f"\nüè• System Health:")
            print(f"  üêç Lua Version: {health.get('lua_version', 'unknown')}")
            print(f"  üì¶ LuaRocks: {'Available' if health.get('luarocks_available') else 'Unavailable'}")
            print(f"  üìä Packages: {health.get('installed_packages', 0)}")
            
            errors = self.env_manager.validate_environment()
            if errors:
                print(f"  ‚ö†Ô∏è  Issues: {len(errors)} problems detected")
            else:
                print(f"  ‚úÖ Environment: OK")
                
        except Exception as e:
            print(f"  ‚ùå Health check error: {e}")

    def list_vms(self):
        if not self.vm_status:
            print("üì≠ No VMs created")
            return

        print("\nüñ•Ô∏è  VM List:")
        print("-" * 80)
        
        for vm_id, status in self.vm_status.items():
            state_indicators = []
            if status.running:
                state_indicators.append("üü¢ Running")
            else:
                state_indicators.append("üî¥ Stopped")
            
            if status.attached:
                state_indicators.append("üîó Attached")
            
            print(f"VM ID: {vm_id}")
            print(f"  Profile: {status.profile}")
            print(f"  Status: {' '.join(state_indicators)}")
            print(f"  Created: {status.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"  Uptime: {status.get_uptime()}")
            print()

    def stop_vm(self):
        if not self.vm_status:
            print("üì≠ No VMs to stop")
            return

        running_vms = {vm_id: status for vm_id, status in self.vm_status.items() 
                      if status.running}

        if not running_vms:
            print("üì≠ No running VMs to stop")
            return

        vm_choices = [
            Choice(f"{vm_id} (Profile: {status.profile})", vm_id)
            for vm_id, status in running_vms.items()
        ]
        vm_choices.append(Choice("‚Üê Back to Menu", "back"))

        vm_id = questionary.select("Select VM to stop:", choices=vm_choices).ask()
        if not vm_id or vm_id == "back":
            return

        confirm = questionary.confirm(
            f"Stop VM '{vm_id}'? This will terminate the session."
        ).ask()

        if not confirm:
            return

        try:
            self.vm_manager.terminate_vm_session(vm_id)
            del self.vm_status[vm_id]
            print(f"‚úÖ VM '{vm_id}' stopped and removed")
        except Exception as e:
            print(f"‚ùå Failed to stop VM: {e}")

    def cleanup(self):
        print("\nüßπ Cleaning up running VMs...")
        for vm_id in list(self.vm_status.keys()):
            if self.vm_status[vm_id].running:
                try:
                    self.vm_manager.terminate_vm_session(vm_id)
                    print(f"‚úÖ VM {vm_id} terminated")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Could not terminate VM {vm_id}: {e}")
        self.vm_status.clear()


if __name__ == "__main__":
    try:
        cli = VMCLI()
        cli.main_menu()
    except KeyboardInterrupt:
        print("\nüëã Goodbye!")
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        import traceback
        traceback.print_exc()